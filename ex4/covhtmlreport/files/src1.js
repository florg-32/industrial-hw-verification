var g_data = {"name":"/home/ferringer/private/lva/labs/vhdl/ex4/ex4.vhd","src":"library common_lib;\ncontext common_lib.common_context;\n\n-- Implement the generic package head here. \npackage linked_list is\n  -- Enter your code here\n  generic (\n    type ElementT;\n    function ToString(item: ElementT) return string\n  );\n\n  type LinkedList is protected\n    --procedure AddLast(item: ElementT);\n    procedure AddFirst(item: ElementT);\n    procedure RemoveAt(index: integer);\n    --procedure AddAfter(index: integer; item: ElementT);\n    impure function Count return integer;\n    --impure function GetFirst return ElementT;\n    --impure function GetLast return ElementT;\n    impure function GetAt(index: integer) return ElementT;\n    impure function Dump return string;\n  end protected;\n  \n  -- REMOVE_END\nend package;\n\n-- Implement the package body here\npackage body linked_list is\n  -- REMOVE_START\n\n  type ListItemT;\n  type ListItemPtrT is access ListItemT;\n  type StringPtrT is access string;\n  type ListItemT is record\n    next_item : ListItemPtrT;\n    item      : ElementT;\n  end record;\n\n  type LinkedList is protected body\n    variable myCount: integer := 0;\n    variable myListStart, myListEnd: ListItemPtrT := null;\n    \n    /*procedure AddLast(item: ElementT) is\n      variable new_item: ListItemPtrT;\n    begin\n      new_item := new ListItemT'(null, item);\n      if myCount = 0 then\n        myListStart := new_item;\n        myListEnd := new_item;\n      else\n        myListEnd.next_item := new_item;\n        myListEnd := new_item;\n      end if;\n      myCount := myCount + 1;\n    end procedure;*/\n\n    procedure AddFirst(item: ElementT) is\n      variable new_item: ListItemPtrT;\n    begin\n      new_item := new ListItemT'(null, item);\n      if myCount = 0 then\n        myListStart := new_item;\n        myListEnd := new_item;\n      else\n        new_item.next_item := myListStart;\n        myListStart := new_item;\n      end if;\n      myCount := myCount + 1;\n    end procedure;\n\n    procedure RemoveAt(index: integer) is\n      variable item, prevItem: ListItemPtrT := null;\n    begin\n      if index >= 0 and index < myCount then\n        item := myListStart;\n        for i in 0 to index - 1 loop\n          prevItem := item;\n          item := item.next_item;\n        end loop;\n        if prevItem /= null then\n          prevItem.next_item := item.next_item;\n        end if;\n        if item = myListStart then\n          myListStart := item.next_item;\n        end if;\n        if item = myListEnd then\n          myListEnd := prevItem;\n        end if;\n        deallocate(item);\n        myCount := myCount - 1;\n      else\n        Alert(\"RemoveAt(): Index \" & to_string(index) & \" is out of range (0..\" & to_string(myCount - 1) & \")\");\n      end if;\n    end procedure;\n\n    /*procedure AddAfter(index: integer; item: ElementT) is\n      variable prevItem: ListItemPtrT := null;\n      variable new_item: ListItemPtrT;\n    begin\n      if index >= 0 and index < myCount then\n        prevItem := myListStart;\n        for i in 0 to index - 1 loop\n          prevItem := prevItem.next_item;\n        end loop;\n        new_item := new ListItemT'(null, item);\n        new_item.next_item := prevItem.next_item;\n        prevItem.next_item := new_item;\n        if prevItem = myListEnd then\n          myListEnd := new_item;\n        end if;\n        myCount := myCount + 1;\n      else\n        Alert(\"AddAfter(): Index \" & to_string(index) & \" is out of range (0..\" & to_string(myCount - 1) & \")\");\n      end if;\n    end procedure;*/\n\n    impure function Count return integer is\n    begin\n      return myCount;\n    end function;\n\n    /*impure function GetFirst return ElementT is\n      variable ret: ElementT;\n    begin\n      if myCount < 0 then\n        Alert(\"GetFirst: No elements in the list\");\n        return ret;\n      end if;\n      return myListStart.item;\n    end function;*/\n\n    /*impure function GetLast return ElementT is\n      variable ret: ElementT;\n    begin\n      if myCount < 0 then\n        Alert(\"GetLast: No elements in the list\");\n        return ret;\n      end if;\n      return myListEnd.item;\n    end function;*/\n\n    impure function GetAt(index: integer) return ElementT is\n      variable ret: ElementT;\n      variable item: ListItemPtrT := null;\n    begin\n      if index >= 0 and index < myCount then\n        item := myListStart;\n        for i in 0 to index - 1 loop\n          item := item.next_item;\n        end loop;\n        return item.item;\n      else\n        Alert(\"GetAt(): Index \" & to_string(index) & \" is out of range (0..\" & to_string(myCount - 1) & \")\");\n        return ret;\n      end if;\n    end function;\n\n    impure function Dump return string is\n      variable item: ListItemPtrT := null;\n      variable text, tmp: StringPtrT := null;\n    begin\n      if myCount > 0 then\n        text := new string'(\"\");\n        item := myListStart;\n        while item /= null loop\n          tmp := text;\n          if text'length > 0 then\n            text := new string'(tmp.all & \", \" & ToString(item.item));\n          else\n            text := new string'(ToString(item.item));\n          end if;\n          deallocate(tmp);\n          item := item.next_item;\n        end loop;\n        return text.all;\n      else\n        return \"Empty.\";\n      end if;\n    end function;\n\n  end protected body;\n  -- REMOVE_END\nend package body;\n\nlibrary common_lib;\ncontext common_lib.common_context;\n\nentity ex4 is\nend entity;\n\narchitecture behav of ex4 is\n\n  type PrimeRecT is record\n    Number: integer;\n    IsPrime: boolean;\n  end record;\n\n  -- implement the ToString function here\n  function ToString(item: PrimeRecT) return string is\n  begin\n  -- REMOVE_START\n    if item.IsPrime then\n      return to_string(item.Number) & \" is a prime\";\n    end if;\n    return to_string(item.Number) & \" is NOT a prime\";\n  -- REMOVE_END\n  end function;\n\n  -- Instantiate the linked_list package here, use PrimeRecT as generic type\n  -- REMOVE_START\n  package prime_pkg is new work.linked_list generic map (PrimeRecT, ToString);\n  use prime_pkg.all;\n\n  pure function GetItem(val: integer; isPrime: boolean) return PrimeRecT is\n    constant ret: PrimeRecT := (val, isPrime);\n  begin\n    return ret;\n  end function;\n  \n  shared variable myList: LinkedList;\n  -- REMOVE_END\n  \nbegin\n\n  stimuli_p: process is\n  begin\n    -- Implement your main testbench code here\n    -- REMOVE_START\n    SetAlertEnable(ALERT_DEFAULT_ID, ERROR, true);\n    SetAlertEnable(ALERT_DEFAULT_ID, WARNING, true);\n    SetAlertEnable(ALERT_DEFAULT_ID, FAILURE, true);\n    SetLogEnable(ALERT_DEFAULT_ID, DEBUG, true);\n    SetLogEnable(ALERT_DEFAULT_ID, FINAL, true);\n    SetLogEnable(ALERT_DEFAULT_ID, INFO, true);\n    SetLogEnable(ALERT_DEFAULT_ID, PASSED, true);\n    Log(\"Starting...\");\n    AffirmIfEqual(myList.Dump, \"Empty.\");\n\n    --myList.AddLast(GetItem(1, true));\n    myList.AddFirst(GetItem(4, false));\n    myList.AddFirst(GetItem(3, true));\n    myList.AddFirst(GetItem(2, true));\n    myList.AddFirst(GetItem(1, true));\n    --myList.AddAfter(1, GetItem(3, true));\n    --myList.AddAfter(0, GetItem(4, false));\n    AffirmIfEqual(myList.Dump, \"1 is a prime, 2 is a prime, 3 is a prime, 4 is NOT a prime\", \"Dump must match\");\n\n    --AffirmIfEqual(ToString(myList.GetFirst), \"2 is a prime\", \"GetFirst\");\n    --AffirmIfEqual(ToString(myList.GetLast), \"3 is a prime\", \"GetLast\");\n    AffirmIfEqual(ToString(myList.GetAt(1)), \"2 is a prime\", \"GetAt\");\n\n    myList.RemoveAt(3);\n    myList.RemoveAt(1);\n    myList.RemoveAt(0);\n    myList.RemoveAt(0);\n    AffirmIfEqual(myList.Dump, \"Empty.\");\n\n    -- REMOVE_END\n    Log(\"**********************************\");\n    std.env.stop;\n    wait ; \n  end process;\n\nend architecture;\n","lang":"vhdl"};
