var g_data = {"name":"/home/ferringer/private/lva/labs/vhdl/osvvm/osvvm/NameStorePkg.vhd","src":"--\n--  File Name:         NameStorePkg.vhd\n--  Design Unit Name:  NameStorePkg\n--  Revision:          STANDARD VERSION\n--\n--  Maintainer:        Jim Lewis      email:  jim@synthworks.com\n--  Contributor(s):\n--     Jim Lewis          SynthWorks\n--\n--\n--  Package Defines\n--      Data structure for name. \n--\n--  Developed for:\n--        SynthWorks Design Inc.\n--        VHDL Training Classes\n--        11898 SW 128th Ave.  Tigard, Or  97223\n--        http://www.SynthWorks.com\n--\n--  Revision History:\n--    Date      Version    Description\n--    06/2021   2021.06    Initial revision.  Derrived from NamePkg.vhd\n--\n--\n--  This file is part of OSVVM.\n--  \n--  Copyright (c) 2021 by SynthWorks Design Inc.  \n--  \n--  Licensed under the Apache License, Version 2.0 (the \"License\");\n--  you may not use this file except in compliance with the License.\n--  You may obtain a copy of the License at\n--  \n--      https://www.apache.org/licenses/LICENSE-2.0\n--  \n--  Unless required by applicable law or agreed to in writing, software\n--  distributed under the License is distributed on an \"AS IS\" BASIS,\n--  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--  See the License for the specific language governing permissions and\n--  limitations under the License.\n--  \n\nuse std.textio.all ;\nuse work.ResolutionPkg.all ; \n\npackage NameStorePkg is\n \n  type NameIDType is record\n    ID : integer_max ;\n  end record NameIDType ; \n  alias NameStoreIDType is NameIDType ; \n  type NameIDArrayType is array (integer range <>) of NameIDType ;  \n\n  constant ID_NOT_FOUND : NameIDType := (ID => -1) ; \n  \n  impure function NewID     (NameIn : String) return NameIDType ;\n--  impure function NewID     (NameIn : String ; Size : positive ) return NameStoreIDArrayType ;\n  procedure       Set       (ID : NameIDType ; NameIn : String) ;\n  impure function Get       (ID : NameIDType ;  DefaultName : string := \"\") return string ;\n  impure function Find (NameIn : String) return NameIDType ;\n  impure function GetOpt    (ID : NameIDType) return string ;\n  impure function IsSet     (ID : NameIDType) return boolean ; \n  procedure       Clear     (ID : NameIDType) ; -- clear name\n  procedure       Deallocate(ID : NameIDType) ; -- effectively alias to clear name\n\n  type NameStorePType is protected\n    impure function NewID     (NameIn : String) return integer ;\n--    impure function NewID     (NameIn : String ; Size : positive ) return integer_vector ;\n    procedure       Set       (ID : integer ; NameIn : String) ;\n    impure function Get       (ID : integer ;  DefaultName : string := \"\") return string ;\n    impure function Find (NameIn : String) return integer ;\n    impure function GetOpt    (ID : integer) return string ;\n    impure function IsSet     (ID : integer) return boolean ; \n    procedure       Clear     (ID : integer) ; -- clear name\n    procedure       Deallocate(ID : integer) ; -- effectively alias to clear name\n  end protected NameStorePType ;\n\nend package NameStorePkg ;\n\n--- ///////////////////////////////////////////////////////////////////////////\n--- ///////////////////////////////////////////////////////////////////////////\n--- ///////////////////////////////////////////////////////////////////////////\n\npackage body NameStorePkg is\n\n  type NameStorePType is protected body\n\n    type  LineArrayType    is array (integer range <>) of Line ; \n    type  LineArrayPtrType is access LineArrayType ;\n\n    variable NameArrayPtr   : LineArrayPtrType ;   \n    variable NumItems       : integer := 0 ; \n--    constant MIN_NUM_ITEMS  : integer := 4 ; -- Temporarily small for testing\n    constant MIN_NUM_ITEMS  : integer := 32 ; -- Min amount to resize array\n\n    ------------------------------------------------------------\n    -- Package Local\n    function NormalizeArraySize( NewNumItems, MinNumItems : integer ) return integer is\n    ------------------------------------------------------------\n      variable NormNumItems : integer ;\n      variable ModNumItems  : integer ;\n    begin\n      NormNumItems := NewNumItems ; \n      ModNumItems  := NewNumItems mod MinNumItems ; \n      if ModNumItems > 0 then \n        NormNumItems := NormNumItems + (MinNumItems - ModNumItems) ; \n      end if ; \n      return NormNumItems ; \n    end function NormalizeArraySize ;\n\n    ------------------------------------------------------------\n    -- Package Local\n    procedure GrowNumberItems (\n    ------------------------------------------------------------\n      variable ItemArrayPtr     : InOut LineArrayPtrType ;\n      constant NewNumItems      : in integer ;\n      constant CurNumItems      : in integer ;\n      constant MinNumItems      : in integer \n    ) is\n      variable oldItemArrayPtr  : LineArrayPtrType ;\n      constant NormNumItems : integer := NormalizeArraySize(NewNumItems, MinNumItems) ;\n    begin\n      if ItemArrayPtr = NULL then\n        ItemArrayPtr := new LineArrayType(1 to NormNumItems) ;\n      elsif NewNumItems > ItemArrayPtr'length then\n        oldItemArrayPtr := ItemArrayPtr ;\n        ItemArrayPtr := new LineArrayType(1 to NormNumItems) ;\n        ItemArrayPtr(1 to CurNumItems) := oldItemArrayPtr(1 to CurNumItems) ;\n        deallocate(oldItemArrayPtr) ;\n      end if ;\n    end procedure GrowNumberItems ;\n\n    ------------------------------------------------------------\n    impure function NewID (NameIn : String) return integer is\n    ------------------------------------------------------------\n      variable NewNumItems : integer ;\n    begin\n      NewNumItems := NumItems + 1 ; \n      GrowNumberItems(NameArrayPtr, NewNumItems, NumItems, MIN_NUM_ITEMS) ;\n      NumItems  := NewNumItems ;\n      Set(NumItems, NameIn) ; \n      return NumItems ; \n    end function NewID ;\n\n    ------------------------------------------------------------\n    procedure Set (ID : integer ; NameIn : String) is\n    ------------------------------------------------------------\n    begin\n      deallocate(NameArrayPtr(ID)) ;\n      NameArrayPtr(ID) := new string'(NameIn) ;\n    end procedure Set ;\n\n    ------------------------------------------------------------\n    impure function Get (ID : integer ; DefaultName : string := \"\") return string is\n    ------------------------------------------------------------\n    begin\n      if NameArrayPtr(ID) = NULL then \n        return DefaultName ; \n      else\n        return NameArrayPtr(ID).all ; \n      end if ; \n    end function Get ;\n\n    ------------------------------------------------------------\n    impure function Find (NameIn : String) return integer is\n    ------------------------------------------------------------\n    begin\n      for ID in 1 to NumItems loop \n        if NameIn = NameArrayPtr(ID).all then \n          return ID ;\n        end if ;\n      end loop ;\n      return ID_NOT_FOUND.ID ;\n    end function Find ;\n\n    ------------------------------------------------------------\n    impure function GetOpt (ID : integer) return string is\n    ------------------------------------------------------------\n    begin\n      if NameArrayPtr(ID) = NULL then \n        return NUL & \"\" ; \n      else\n        return NameArrayPtr(ID).all ; \n      end if ; \n    end function GetOpt ;\n\n    ------------------------------------------------------------\n    impure function IsSet (ID : integer) return boolean is \n    ------------------------------------------------------------\n    begin\n      return NameArrayPtr(ID) /= NULL ; \n    end function IsSet ;      \n    \n    ------------------------------------------------------------\n    procedure Clear (ID : integer) is\n    ------------------------------------------------------------\n    begin\n      deallocate(NameArrayPtr(ID)) ;\n    end procedure Clear ;\n    \n    ------------------------------------------------------------\n    procedure Deallocate(ID : integer) is\n    ------------------------------------------------------------\n    begin\n      Clear(ID) ;\n    end procedure Deallocate ;\n  end protected body NameStorePType ;\n  \n\n-- /////////////////////////////////////////\n-- /////////////////////////////////////////\n-- Singleton Data Structure\n-- /////////////////////////////////////////\n-- /////////////////////////////////////////\n  shared variable NameStore : NameStorePType ; \n  \n  ------------------------------------------------------------\n  impure function NewID (NameIn : String) return NameIDType is\n  ------------------------------------------------------------\n    variable Result : NameIDType ; \n  begin\n    Result.ID := NameStore.NewID(NameIn) ;\n    return Result ; \n  end function NewID ;\n\n  ------------------------------------------------------------\n  procedure Set (ID : NameIDType ; NameIn : String) is\n  ------------------------------------------------------------\n  begin\n    NameStore.set(ID.ID, NameIn) ;\n  end procedure Set ;\n\n  ------------------------------------------------------------\n  impure function Get (ID : NameIDType ; DefaultName : string := \"\") return string is\n  ------------------------------------------------------------\n  begin\n    return NameStore.Get(ID.ID, DefaultName) ;\n  end function Get ;\n\n  ------------------------------------------------------------\n  impure function Find (NameIn : String) return NameIDType is\n  ------------------------------------------------------------\n  begin\n    return NameIDType'(ID => NameStore.Find(NameIn)) ;\n  end function Find ;\n\n  ------------------------------------------------------------\n  impure function GetOpt (ID : NameIDType) return string is\n  ------------------------------------------------------------\n  begin\n    return NameStore.Get(ID.ID) ;\n  end function GetOpt ;\n\n  ------------------------------------------------------------\n  impure function IsSet (ID : NameIDType) return boolean is \n  ------------------------------------------------------------\n  begin\n    return NameStore.IsSet(ID.ID) ;\n  end function IsSet ;      \n  \n  ------------------------------------------------------------\n  procedure Clear (ID : NameIDType) is\n  ------------------------------------------------------------\n  begin\n    NameStore.Clear(ID.ID) ;\n  end procedure Clear ;\n  \n  ------------------------------------------------------------\n  procedure Deallocate(ID : NameIDType) is\n  ------------------------------------------------------------\n  begin\n    NameStore.Clear(ID.ID) ;\n  end procedure Deallocate ;\n  \nend package body NameStorePkg ;","lang":"vhdl"};
processSrcData(g_data);