var g_data = {"name":"/home/ferringer/private/lva/labs/vhdl/osvvm/Common/src/StreamTransactionPkg.vhd","src":"--\n--  File Name:         StreamTransactionPkg.vhd\n--  Design Unit Name:  StreamTransactionPkg\n--  Revision:          OSVVM MODELS STANDARD VERSION\n--\n--  Maintainer:        Jim Lewis      email:  jim@synthworks.com\n--  Contributor(s):\n--     Jim Lewis      jim@synthworks.com\n--\n--\n--  Description:\n--    The Stream Model Independent Transaction package (StreamTransactionTransactionPkg.vhd) \n--    defines a record for communication and transaction initiation procedures \n--    that are suitable for Stream Interfaces.   \n--\n--\n--  Developed by:\n--        SynthWorks Design Inc.\n--        VHDL Training Classes\n--        http://www.SynthWorks.com\n--\n--  Revision History:\n--    Date      Version    Description\n--    06/2021   2021.06    Updated bursting \n--    10/2020   2020.10    Added bursting to stream transactions\n--    09/2020   2020.09    Updating comments to serve as documentation\n--    07/2020   2020.07    Updated\n--    01/2020   2020.01    Updated license notice\n--    07/2019   2019.07    Refactored from UartTbPkg and AxiStreamTransactionPkg\n--\n--\n--  This file is part of OSVVM.\n--  \n--  Copyright (c) 2019 - 2021 by SynthWorks Design Inc.  \n--  \n--  Licensed under the Apache License, Version 2.0 (the \"License\");\n--  you may not use this file except in compliance with the License.\n--  You may obtain a copy of the License at\n--  \n--      https://www.apache.org/licenses/LICENSE-2.0\n--  \n--  Unless required by applicable law or agreed to in writing, software\n--  distributed under the License is distributed on an \"AS IS\" BASIS,\n--  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--  See the License for the specific language governing permissions and\n--  limitations under the License.\n--  \n\nlibrary ieee ;\n  use ieee.std_logic_1164.all ;\n  use ieee.numeric_std.all ;\n  use ieee.numeric_std_unsigned.all ;\n\n  use std.textio.all ;\n\nlibrary osvvm ; \n  context osvvm.OsvvmContext ;  \n  use osvvm.ScoreboardPkg_slv.all ; \n  \npackage StreamTransactionPkg is \n\n  -- ========================================================\n  --  StreamOperationType \n  --  Enumeration type used to communication transaction type\n  --  to the model via the transaction interface\n  -- ========================================================\n  type StreamUnresolvedOperationType is (\n    -- Default. Used for Multiple Driver Detection\n    NOT_DRIVEN,  \n    -- Directives\n    WAIT_FOR_CLOCK, \n    WAIT_FOR_TRANSACTION,\n    GET_TRANSACTION_COUNT,\n    GET_ALERTLOG_ID,\n    -- Burst FIFO Configuration\n    SET_BURST_MODE,\n    GET_BURST_MODE,\n    -- Model Options\n    SET_MODEL_OPTIONS,\n    GET_MODEL_OPTIONS,\n    --  Transmitter\n    SEND, \n    SEND_ASYNC,\n    SEND_BURST,\n    SEND_BURST_ASYNC,\n    -- Receiver\n    GET,             \n    TRY_GET,\n    GET_BURST,\n    TRY_GET_BURST,\n    CHECK,\n    TRY_CHECK,\n    CHECK_BURST,\n    TRY_CHECK_BURST,\n    MULTIPLE_DRIVER_DETECT  -- value used when multiple drivers are present\n  ) ;\n  type StreamUnresolvedOperationVectorType is array (natural range <>) of StreamUnresolvedOperationType ;\n  -- Maximum is implicitly defined for any array type in VHDL-2008.   \n  -- alias resolved_max is maximum[ StreamUnresolvedOperationVectorType return StreamUnresolvedOperationType] ;\n  -- Function resolved_max is a fall back.\n  function resolved_max ( s : StreamUnresolvedOperationVectorType) return StreamUnresolvedOperationType ;\n  subtype StreamOperationType is resolved_max StreamUnresolvedOperationType ;\n\n  -- ========================================================\n  --  Stream Transaction Interface (StreamRecType) \n  --  The Stream Transaction Interface (StreamRecType) defines the \n  --  transaction interface between the test sequencer and the \n  --  verification component.   As such, it is the primary channel for \n  --  information exchange between the two.   It is defined as follows.\n  --\n  --  The record element types, bit_max, std_logic_vector_max_c, \n  --  integer_max, time_max, and boolean_max, are defined in the\n  --  OSVVM package ResolutionPkg.  These types allow the record to \n  --  support multiple drivers and use resolution functions based on \n  --  function maximum (return largest value). \n  -- ========================================================\n  type StreamRecType is record\n    -- Handshaking controls\n    --   Used by RequestTransaction in the Transaction Procedures\n    --   Used by WaitForTransaction in the Verification Component\n    --   RequestTransaction and WaitForTransaction are in osvvm.TbUtilPkg\n    Rdy             : RdyType ;\n    Ack             : AckType ;\n    -- Transaction Type\n    Operation       : StreamOperationType ;\n    -- Data and Transaction Parameter to and from verification component \n    DataToModel     : std_logic_vector_max_c ; \n    ParamToModel    : std_logic_vector_max_c ; \n    DataFromModel   : std_logic_vector_max_c ; \n    ParamFromModel  : std_logic_vector_max_c ; \n    -- BurstFifo\n    BurstFifo       : ScoreboardIdType ; \n    -- Verification Component Options Parameters - used by SetModelOptions\n    IntToModel      : integer_max ;\n    IntFromModel    : integer_max ; \n    BoolToModel     : boolean_max ; \n    BoolFromModel   : boolean_max ;\n    TimeToModel     : time_max ; \n    TimeFromModel   : time_max ; \n    -- Verification Component Options Type \n    Options         : integer_max ; \n  end record StreamRecType ; \n\n\n  -- --------------------------------------------------------\n  -- Usage of the Transaction Interface (StreamRecType)\n  -- The Data and Parameter fields of StreamRecType are unconstrained.\n  -- Unconstrained objects may be used on component/entity interfaces.    \n  -- The record fields will be sized by the record signal that is mapped\n  -- as the actual in the test harness of the testbench.  \n  -- Such a declaration is shown below:\n  --\n  --   signal StreamTxRec, StreamRxRec : StreamRecType(\n  --         DataToModel   (AXI_DATA_WIDTH-1  downto 0),\n  --         ParamToModel  (AXI_PARAM_WIDTH-1 downto 0),\n  --         DataFromModel (AXI_DATA_WIDTH-1  downto 0),\n  --         ParamFromModel(AXI_PARAM_WIDTH-1 downto 0)\n  --       ) ; \n  --\n  -- --------------------------------------------------------\n  \n\n--!TODO add VHDL-2019 Interfaces\n\n\n  -- ========================================================\n  --  Types of Transactions\n  --  A transaction may be either a directive or an interface transaction.\n  --\n  --  Directive transactions interact with the verification component \n  --  without generating any transactions or interface waveforms.\n  --\n  --  An interface transaction results in interface signaling to the DUT.\n  --  An interface transaction may be either blocking (such as Send or Get)\n  --  or non-blocking (such as SendAsync or TryGet).\n  --\n  --  A blocking transaction is an interface transaction that does not \n  --  does not return (complete) until the interface operation   \n  --  requested by the transaction has completed.\n  --\n  --  An asynchronous transaction is nonblocking interface transaction\n  --  that returns before the transaction has completed - typically \n  --  immediately and before the transaction has started.   \n  --  An asynchronous transaction has \"Async\" as part of its name.\n  --\n  --  A Try transaction is nonblocking interface transaction that \n  --  checks to see if transaction information is available, \n  --  such as read data, and if it is returns it.  \n  --  A Try transaction has \"Try\" as part of its name.\n  --\n  -- ========================================================\n\n\n  -- ========================================================\n  --  Directive Transactions  \n  --  Directive transactions interact with the verification component \n  --  without generating any transactions or interface waveforms.\n  --  Supported by all verification components\n  -- ========================================================\n  ------------------------------------------------------------\n  procedure WaitForTransaction (\n  --  Wait until pending (transmit) or next (receive) transaction(s) complete\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType \n  ) ; \n\n  ------------------------------------------------------------\n  procedure WaitForClock (\n  -- Wait for NumberOfClocks number of clocks \n  -- relative to the verification component clock\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType ;\n    constant  WaitCycles      : in    natural := 1\n  ) ; \n  \n alias NoOp is WaitForClock [StreamRecType, natural] ;\n\n  ------------------------------------------------------------\n  procedure GetTransactionCount (\n  -- Get the number of transactions handled by the model.  \n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    variable  TransactionCount : out   integer \n  ) ; \n\n  ------------------------------------------------------------\n  procedure GetAlertLogID (\n  -- Get the AlertLogID from the verification component.\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType ;\n    variable  AlertLogID      : out   AlertLogIDType \n  ) ; \n  \n  ------------------------------------------------------------\n  procedure GetErrorCount (\n  -- Error reporting for testbenches that do not use OSVVM AlertLogPkg\n  -- Returns error count.  If an error count /= 0, also print errors\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType ;\n    variable  ErrorCount      : out   natural\n  ) ; \n  \n  -- ========================================================\n  -- BurstFIFOs and Burst Mode Controls\n  -- The burst FIFOs hold bursts of data that is to be sent to \n  -- or was received from the interface.   The burst FIFO can be \n  -- configured in the modes defined for StreamFifoBurstModeType.\n  -- Currently these modes defined as a subtype of integer, shown below.\n  -- The intention of using integers is to facilitate model specific \n  -- extensions without the need to define separate transactions.\n  -- ========================================================\n  subtype StreamFifoBurstModeType is integer ;\n  \n  -- Word mode indicates the burst FIFO contains interface words.\n  -- The size of the word may either be interface specific (such as \n  -- a UART which supports up to 8 bits) or be interface instance specific \n  -- (such as AxiStream which supports interfaces sizes of 1, 2, 4, 8, \n  -- 16, ... bytes)\n  constant STREAM_BURST_WORD_MODE       : StreamFifoBurstModeType  := 0 ;\n  \n  -- Word + Param mode indicates the burst FIFO contains interface \n  -- words plus a parameter.   The size of the parameter is also either\n  -- interface specific (such as the OSVVM UART, which uses 3 bits - \n  -- one bit for each of parity, stop, and break error injection) or\n  -- interface instance specific (such as AxiStream which uses the Param\n  -- field to hold TUser).  AxiStream TUser may be different size for\n  -- different applications.\n  constant STREAM_BURST_WORD_PARAM_MODE : StreamFifoBurstModeType  := 1 ;\n  \n  -- Byte mode is experimental and may be removed in a future revision.\n  -- Byte mode indicates that the burst FIFO contains bytes.  \n  -- The verification component assembles interface words from the bytes.\n  -- This allows transfers to be conceptualized in an interface independent \n  --manner.    \n  constant STREAM_BURST_BYTE_MODE       : StreamFifoBurstModeType  := 2 ; \n    \n  ------------------------------------------------------------\n  --  SetBurstMode and GetBurstMode\n  --  are directive transactions that configure the burst mode \n  --  into one of the modes defined for StreamFifoBurstModeType\n  ------------------------------------------------------------\n  ------------------------------------------------------------\n  procedure SetBurstMode (\n  ------------------------------------------------------------\n    signal   TransactionRec  : InOut StreamRecType ;\n    constant OptVal          : In    StreamFifoBurstModeType\n  ) ;\n\n  ------------------------------------------------------------\n  procedure GetBurstMode (\n  ------------------------------------------------------------\n    signal   TransactionRec  : InOut StreamRecType ;\n    variable OptVal          : Out   StreamFifoBurstModeType\n  ) ;\n\n\n  -- ========================================================\n  --  Set and Get Model Options  \n  --  Model operations are directive transactions that are  \n  --  used to configure the verification component.  \n  --  They can either be used directly or with a model specific\n  --  wrapper around them - see AXI models for examples.\n  -- ========================================================\n  ------------------------------------------------------------\n  procedure SetModelOptions (\n  ------------------------------------------------------------\n    signal   TransactionRec  : InOut StreamRecType ;\n    constant Option          : In    integer ;\n    constant OptVal          : In    boolean\n  ) ;\n\n  ------------------------------------------------------------\n  procedure SetModelOptions (\n  ------------------------------------------------------------\n    signal   TransactionRec  : InOut StreamRecType ;\n    constant Option          : In    integer ;\n    constant OptVal          : In    integer\n  ) ;\n\n  ------------------------------------------------------------\n  procedure SetModelOptions (\n  ------------------------------------------------------------\n    signal   TransactionRec  : InOut StreamRecType ;\n    constant Option          : In    integer ;\n    constant OptVal          : In    std_logic_vector\n  ) ;\n  \n  ------------------------------------------------------------\n  procedure SetModelOptions (\n  ------------------------------------------------------------\n    signal   TransactionRec  : InOut StreamRecType ;\n    constant Option          : In    integer ;\n    constant OptVal          : In    time\n  ) ;\n  \n  ------------------------------------------------------------\n  procedure SetModelOptions (\n  ------------------------------------------------------------\n    signal   TransactionRec  : InOut StreamRecType ;\n    constant Option          : In    integer \n  ) ;\n  \n  ------------------------------------------------------------\n  procedure GetModelOptions (\n  ------------------------------------------------------------\n    signal   TransactionRec  : InOut StreamRecType ;\n    constant Option          : In    integer ;\n    variable OptVal          : Out   boolean\n  ) ;\n\n  ------------------------------------------------------------\n  procedure GetModelOptions (\n  ------------------------------------------------------------\n    signal   TransactionRec  : InOut StreamRecType ;\n    constant Option          : In    integer ;\n    variable OptVal          : Out   integer\n  ) ;\n\n  ------------------------------------------------------------\n  procedure GetModelOptions (\n  ------------------------------------------------------------\n    signal   TransactionRec  : InOut StreamRecType ;\n    constant Option          : In    integer ;\n    variable OptVal          : Out   std_logic_vector\n  ) ;\n  \n  ------------------------------------------------------------\n  procedure GetModelOptions (\n  ------------------------------------------------------------\n    signal   TransactionRec  : InOut StreamRecType ;\n    constant Option          : In    integer ;\n    variable OptVal          : Out   time\n  ) ;\n  \n  ------------------------------------------------------------\n  procedure GetModelOptions (\n  ------------------------------------------------------------\n    signal   TransactionRec  : InOut StreamRecType ;\n    constant Option          : In    integer \n  ) ;\n\n\n  -- ========================================================\n  --  Transmitter Transactions\n  -- ========================================================\n\n  -- ========================================================\n  -- Send\n  -- Blocking Send Transaction. \n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for error injection.\n  -- ========================================================\n  \n  ------------------------------------------------------------\n  procedure Send (\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType ;\n    constant  Data            : in    std_logic_vector ;\n    constant  Param           : in    std_logic_vector ;\n    constant  StatusMsgOn     : in    boolean := FALSE \n  ) ; \n\n  ------------------------------------------------------------\n  procedure Send (\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType ;\n    constant  Data            : in    std_logic_vector ;\n    constant  StatusMsgOn     : in    boolean := FALSE \n  ) ; \n  \n\n  -- ========================================================\n  -- SendAsync\n  -- Asynchronous / Non-Blocking Send Transaction\n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for error injection. \n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure SendAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType ;\n    constant  Data            : in    std_logic_vector ;\n    constant  Param           : in    std_logic_vector ;\n    constant  StatusMsgOn     : in    boolean := FALSE \n  ) ; \n\n  ------------------------------------------------------------\n  procedure SendAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType ;\n    constant  Data            : in    std_logic_vector ;\n    constant  StatusMsgOn     : in    boolean := FALSE \n  ) ; \n\n\n  -- ========================================================\n  -- SendBurst\n  -- Blocking Send Burst Transaction. \n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for error injection.\n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure SendBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType ;\n    constant  NumFifoWords    : In    integer ;\n    constant  Param           : in    std_logic_vector ;\n    constant  StatusMsgOn     : in    boolean := FALSE \n  ) ; \n\n  ------------------------------------------------------------\n  procedure SendBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType ;\n    constant  NumFifoWords    : In    integer ;\n    constant  StatusMsgOn     : in    boolean := FALSE \n  ) ; \n\n  -- ========================================================\n  -- SendBurstAsync\n  -- Asynchronous / Non-Blocking Send Transaction\n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for error injection. \n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure SendBurstAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType ;\n    constant  NumFifoWords    : In    integer ;\n    constant  Param           : in    std_logic_vector ;\n    constant  StatusMsgOn     : in    boolean := FALSE \n  ) ; \n\n  ------------------------------------------------------------\n  procedure SendBurstAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType ;\n    constant  NumFifoWords    : In    integer ;\n    constant  StatusMsgOn     : in    boolean := FALSE \n  ) ; \n  \n\n  -- ========================================================\n  --  Receiver Transactions\n  -- ========================================================\n\n  -- ========================================================\n  -- Get\n  -- Blocking Get Transaction. \n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for received error status.\n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure Get (\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType ;\n    variable  Data            : out   std_logic_vector ;\n    variable  Param           : out   std_logic_vector ;\n    constant  StatusMsgOn     : in    boolean := FALSE \n  ) ; \n\n  ------------------------------------------------------------\n  procedure Get (\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType ;\n    variable  Data            : out   std_logic_vector ;\n    constant  StatusMsgOn     : in    boolean := FALSE \n  ) ; \n\n\n  -- ========================================================\n  -- TryGet\n  -- Try Get Transaction\n  -- If Data is available, get it and return available TRUE,\n  -- otherwise Return Available FALSE.\n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for received error status.\n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure TryGet (\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType ;\n    variable  Data            : out   std_logic_vector ;\n    variable  Available       : out   boolean ;\n    constant  StatusMsgOn     : in    boolean := FALSE \n  ) ; \n  \n  ------------------------------------------------------------\n  procedure TryGet (\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType ;\n    variable  Data            : out   std_logic_vector ;\n    variable  Param           : out   std_logic_vector ;\n    variable  Available       : out   boolean ;\n    constant  StatusMsgOn     : in    boolean := FALSE \n  ) ;  \n\n\n  -- ========================================================\n  -- GetBurst\n  -- Blocking Get Burst Transaction. \n  -- Param, when present, is an extra parameter from the verification component\n  -- The UART verification component uses Param for received error status.\n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure GetBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType ;\n    variable  NumFifoWords    : inout integer ;\n    constant  StatusMsgOn     : in    boolean := FALSE \n  ) ; \n  \n  ------------------------------------------------------------\n  procedure GetBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType ;\n    variable  NumFifoWords    : inout integer ;\n    variable  Param           : out   std_logic_vector ;\n    constant  StatusMsgOn     : in    boolean := FALSE \n  ) ;  \n\n  -- ========================================================\n  -- TryGetBurst\n  -- Try Get Burst Transaction\n  -- If Data is available, get it and return available TRUE,\n  -- otherwise Return Available FALSE.\n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for received error status.\n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure TryGetBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType ;\n    variable  NumFifoWords    : inout integer ;\n    variable  Available       : out   boolean ;\n    constant  StatusMsgOn     : in    boolean := FALSE \n  ) ; \n  \n  ------------------------------------------------------------\n  procedure TryGetBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType ;\n    variable  NumFifoWords    : inout integer ;\n    variable  Param           : out   std_logic_vector ;\n    variable  Available       : out   boolean ;\n    constant  StatusMsgOn     : in    boolean := FALSE \n  ) ;  \n\n\n  -- ========================================================\n  -- Check\n  -- Blocking Check Transaction. \n  -- Data is the expected value to be received.\n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for received error status.\n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure Check (\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType ;\n    constant  Data            : in    std_logic_vector ;\n    constant  Param           : in    std_logic_vector ;\n    constant  StatusMsgOn     : in    boolean := FALSE \n  ) ; \n\n  ------------------------------------------------------------\n  procedure Check (\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType ;\n    constant  Data            : in    std_logic_vector ;\n    constant  StatusMsgOn     : in    boolean := FALSE \n  ) ; \n\n\n  -- ========================================================\n  -- TryCheck\n  -- Try Check Transaction\n  -- If Data is available, check it and return available TRUE,\n  -- otherwise Return Available FALSE.\n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for received error status.\n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure TryCheck (\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType ;\n    constant  Data            : in    std_logic_vector ;\n    constant  Param           : in    std_logic_vector ;\n    variable  Available       : out   boolean ;\n    constant  StatusMsgOn     : in    boolean := FALSE \n  ) ; \n\n  ------------------------------------------------------------\n  procedure TryCheck (\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType ;\n    constant  Data            : in    std_logic_vector ;\n    variable  Available       : out   boolean ;\n    constant  StatusMsgOn     : in    boolean := FALSE \n  ) ; \n\n  -- ========================================================\n  -- CheckBurst\n  -- Blocking Check Burst Transaction. \n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for checking error injection.\n  -- ========================================================\n  ------------------------------------------------------------\n  procedure CheckBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType ;\n    constant  NumFifoWords    : In    integer ;\n    constant  Param           : in    std_logic_vector ;\n    constant  StatusMsgOn     : in    boolean := FALSE \n  ) ; \n\n  ------------------------------------------------------------\n  procedure CheckBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType ;\n    constant  NumFifoWords    : In    integer ;\n    constant  StatusMsgOn     : in    boolean := FALSE \n  ) ; \n\n  -- ========================================================\n  -- TryCheckBurst\n  -- Try / Non-Blocking Check Burst Transaction\n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for error injection. \n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure TryCheckBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType ;\n    constant  NumFifoWords    : In    integer ;\n    constant  Param           : in    std_logic_vector ;\n    variable  Available       : out   boolean ;\n    constant  StatusMsgOn     : in    boolean := FALSE \n  ) ; \n\n  ------------------------------------------------------------\n  procedure TryCheckBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType ;\n    constant  NumFifoWords    : In    integer ;\n    variable  Available       : out   boolean ;\n    constant  StatusMsgOn     : in    boolean := FALSE \n  ) ; \n  \n  -- ========================================================\n  --  Pseudo Transactions\n  --  Interact with the record only.\n  -- ========================================================\n  ------------------------------------------------------------\n  procedure ReleaseTransactionRecord (\n  --  Must run on same delta cycle as AcquireTransactionRecord\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType \n  ) ; \n  \n  ------------------------------------------------------------\n  procedure AcquireTransactionRecord (\n  --  Must run on same delta cycle as ReleaseTransactionRecord\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType \n  ) ; \n\n  -- ========================================================\n  --  Verification Component Support Functions\n  --  These help decode the operation value (StreamOperationType)  \n  --  to determine properties about the operation\n  -- ========================================================\n  ------------------------------------------------------------\n  function IsBlocking (\n  -----------------------------------------------------------\n    constant Operation     : in StreamOperationType\n  ) return boolean ;\n  \n  ------------------------------------------------------------\n  function IsTry (\n  -- True when this transaction is an asynchronous or try transaction.\n  -----------------------------------------------------------\n    constant Operation     : in StreamOperationType\n  ) return boolean ;\n\n  ------------------------------------------------------------\n  function IsCheck (\n  -- True when this transaction is a check transaction.\n  -----------------------------------------------------------\n    constant Operation     : in StreamOperationType\n  ) return boolean ;\n\nend StreamTransactionPkg ;\n\npackage body StreamTransactionPkg is \n\n  ------------------------------------------------------------\n  function resolved_max ( s : StreamUnresolvedOperationVectorType) return StreamUnresolvedOperationType is\n  ------------------------------------------------------------\n    variable Result : StreamUnresolvedOperationType := NOT_DRIVEN ;\n  begin\n    for i in s'range loop \n      if s(i) > NOT_DRIVEN then \n        if result = NOT_DRIVEN then \n          result := s(i) ;\n        else\n          result := MULTIPLE_DRIVER_DETECT ;\n        end if ; \n      end if ; \n    end loop ;\n    return result ; \n--    return maximum(s) ;\n  end function resolved_max ; \n\n\n  -- ========================================================\n  --  Directive Transactions  \n  --  Directive transactions interact with the verification component \n  --  without generating any transactions or interface waveforms.\n  --  Supported by all verification components\n  -- ========================================================\n  ------------------------------------------------------------\n  procedure WaitForTransaction (\n  --  Wait until pending (transmit) or next (receive) transaction(s) complete\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType \n  ) is\n  begin\n    TransactionRec.Operation   <= WAIT_FOR_TRANSACTION ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ; \n  end procedure WaitForTransaction ; \n\n  ------------------------------------------------------------\n  procedure WaitForClock (\n  -- Wait for NumberOfClocks number of clocks \n  -- relative to the verification component clock\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType ;\n    constant  WaitCycles      : in    natural := 1\n  ) is\n  begin\n    TransactionRec.Operation   <= WAIT_FOR_CLOCK ;\n    TransactionRec.IntToModel  <= WaitCycles ; \n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ; \n  end procedure WaitForClock ; \n\n  ------------------------------------------------------------\n  procedure GetTransactionCount (\n  -- Get the number of transactions handled by the model.  \n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    variable  TransactionCount : out   integer \n  ) is\n  begin\n    TransactionRec.Operation   <= GET_TRANSACTION_COUNT ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ; \n    TransactionCount := TransactionRec.IntFromModel ; \n  end procedure GetTransactionCount ; \n\n  ------------------------------------------------------------\n  procedure GetAlertLogID (\n  -- Get the AlertLogID from the verification component.\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType ;\n    variable  AlertLogID      : out   AlertLogIDType \n  ) is\n  begin\n    TransactionRec.Operation   <= GET_ALERTLOG_ID ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ; \n    AlertLogID := AlertLogIDType(TransactionRec.IntFromModel) ; \n  end procedure GetAlertLogID ; \n  \n  ------------------------------------------------------------\n  procedure GetErrorCount (\n  -- Error reporting for testbenches that do not use OSVVM AlertLogPkg\n  -- Returns error count.  If an error count /= 0, also print errors\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType ;\n    variable  ErrorCount      : out   natural\n  ) is\n    variable  AlertLogID : AlertLogIDType ;\n  begin\n    GetAlertLogID(TransactionRec, AlertLogID) ;\n--    ReportNonZeroAlerts(AlertLogID => AlertLogID) ;\n    ErrorCount := GetAlertCount(AlertLogID => AlertLogID) ;\n  end procedure GetErrorCount ; \n  \n  \n  -- ========================================================\n  --  Set and Get Burst Mode   \n  --  Set Burst Mode for models that do bursting.\n  -- ========================================================\n  ------------------------------------------------------------\n  procedure SetBurstMode (\n  ------------------------------------------------------------\n    signal   TransactionRec    : InOut StreamRecType ;\n    constant OptVal      : In    StreamFifoBurstModeType\n  ) is\n  begin\n    TransactionRec.Operation     <= SET_BURST_MODE ;\n    TransactionRec.IntToModel    <= OptVal ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n  end procedure SetBurstMode ;\n\n  ------------------------------------------------------------\n  procedure GetBurstMode (\n  ------------------------------------------------------------\n    signal   TransactionRec    : InOut StreamRecType ;\n    variable OptVal      : Out   StreamFifoBurstModeType\n  ) is\n  begin\n    TransactionRec.Operation     <= GET_BURST_MODE ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n    OptVal := TransactionRec.IntFromModel ; \n  end procedure GetBurstMode ;\n\n\n  -- ========================================================\n  --  Set and Get Model Options  \n  --  Model operations are directive transactions that are  \n  --  used to configure the verification component.  \n  --  They can either be used directly or with a model specific\n  --  wrapper around them - see AXI models for examples.\n  -- ========================================================\n  ------------------------------------------------------------\n  procedure SetModelOptions (\n  ------------------------------------------------------------\n    signal   TransactionRec  : InOut StreamRecType ;\n    constant Option          : In    integer ;\n    constant OptVal          : In    boolean\n  ) is\n  begin\n    TransactionRec.Operation     <= SET_MODEL_OPTIONS ;\n    TransactionRec.Options       <= Option ;\n    TransactionRec.BoolToModel   <= OptVal ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n  end procedure SetModelOptions ;\n\n  ------------------------------------------------------------\n  procedure SetModelOptions (\n  ------------------------------------------------------------\n    signal   TransactionRec  : InOut StreamRecType ;\n    constant Option          : In    integer ;\n    constant OptVal          : In    integer\n  ) is\n  begin\n    TransactionRec.Operation     <= SET_MODEL_OPTIONS ;\n    TransactionRec.Options       <= Option ;\n    TransactionRec.IntToModel    <= OptVal ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n  end procedure SetModelOptions ;\n\n  ------------------------------------------------------------\n  procedure SetModelOptions (\n  ------------------------------------------------------------\n    signal   TransactionRec  : InOut StreamRecType ;\n    constant Option          : In    integer ;\n    constant OptVal          : In    std_logic_vector\n  ) is\n  begin\n    TransactionRec.Operation     <= SET_MODEL_OPTIONS ;\n    TransactionRec.Options       <= Option ;\n    TransactionRec.IntToModel    <= to_integer(OptVal) ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n  end procedure SetModelOptions ;\n  \n  ------------------------------------------------------------\n  procedure SetModelOptions (\n  ------------------------------------------------------------\n    signal   TransactionRec  : InOut StreamRecType ;\n    constant Option          : In    integer ;\n    constant OptVal          : In    time\n  ) is\n  begin\n    TransactionRec.Operation     <= SET_MODEL_OPTIONS ;\n    TransactionRec.Options       <= Option ;\n    TransactionRec.TimeToModel   <= OptVal ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n  end procedure SetModelOptions ;\n\n  ------------------------------------------------------------\n  procedure SetModelOptions (\n  ------------------------------------------------------------\n    signal   TransactionRec  : InOut StreamRecType ;\n    constant Option          : In    integer \n  ) is\n  begin\n    TransactionRec.Operation     <= SET_MODEL_OPTIONS ;\n    TransactionRec.Options       <= Option ;\n    -- OptVal handled by Model Specific Package\n    -- TransactionRec.IntToModel    <= to_integer(OptVal) ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n  end procedure SetModelOptions ;\n\n  ------------------------------------------------------------\n  procedure GetModelOptions (\n  ------------------------------------------------------------\n    signal   TransactionRec  : InOut StreamRecType ;\n    constant Option          : In    integer ;\n    variable OptVal          : Out   boolean\n  ) is\n  begin\n    TransactionRec.Operation     <= GET_MODEL_OPTIONS ;\n    TransactionRec.Options       <= Option ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n    OptVal := TransactionRec.BoolFromModel    ;\n  end procedure GetModelOptions ;\n\n  ------------------------------------------------------------\n  procedure GetModelOptions (\n  ------------------------------------------------------------\n    signal   TransactionRec  : InOut StreamRecType ;\n    constant Option          : In    integer ;\n    variable OptVal          : Out   integer\n  ) is\n  begin\n    TransactionRec.Operation     <= GET_MODEL_OPTIONS ;\n    TransactionRec.Options       <= Option ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n    OptVal := TransactionRec.IntFromModel ; \n  end procedure GetModelOptions ;\n\n  ------------------------------------------------------------\n  procedure GetModelOptions (\n  ------------------------------------------------------------\n    signal   TransactionRec  : InOut StreamRecType ;\n    constant Option          : In    integer ;\n    variable OptVal          : Out   std_logic_vector\n  ) is\n  begin\n    TransactionRec.Operation     <= GET_MODEL_OPTIONS ;\n    TransactionRec.Options       <= Option ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n    OptVal := to_slv(TransactionRec.IntFromModel, OptVal'length) ; \n  end procedure GetModelOptions ;\n  \n  ------------------------------------------------------------\n  procedure GetModelOptions (\n  ------------------------------------------------------------\n    signal   TransactionRec  : InOut StreamRecType ;\n    constant Option          : In    integer ;\n    variable OptVal          : Out   time\n  ) is\n  begin\n    TransactionRec.Operation     <= GET_MODEL_OPTIONS ;\n    TransactionRec.Options       <= Option ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n    OptVal := TransactionRec.TimeFromModel ; \n  end procedure GetModelOptions ;\n\n  ------------------------------------------------------------\n  procedure GetModelOptions (\n  ------------------------------------------------------------\n    signal   TransactionRec  : InOut StreamRecType ;\n    constant Option          : In    integer \n  ) is\n  begin\n    TransactionRec.Operation     <= GET_MODEL_OPTIONS ;\n    TransactionRec.Options       <= Option ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n    -- OptVal handled by Model Specific layer overloading\n    -- OptVal := TransactionRec.TimeFromModel ; \n  end procedure GetModelOptions ;\n\n\n  -- ========================================================\n  --  Transmitter Transactions\n  -- ========================================================\n  \n  -- ========================================================\n  -- Send\n  -- Blocking Send Transaction. \n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for error injection.\n  -- ========================================================\n  ------------------------------------------------------------\n  procedure LocalSend (\n  -- Package Local - simplifies the other calls to Send\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType ;\n    constant  Operation       : in    StreamOperationType ;\n    constant  Data            : in    std_logic_vector ;\n    constant  Param           : in    std_logic_vector ;\n    constant  StatusMsgOn     : in    boolean := FALSE \n  ) is \n  begin\n    TransactionRec.Operation     <= Operation ;\n    TransactionRec.DataToModel   <= SafeResize(Data, TransactionRec.DataToModel'length) ; \n    TransactionRec.ParamToModel  <= SafeResize(Param, TransactionRec.ParamToModel'length) ; \n    TransactionRec.IntToModel    <= Data'length ;\n    TransactionRec.BoolToModel   <= StatusMsgOn ; \n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ; \n  end procedure LocalSend ; \n\n  ------------------------------------------------------------\n  procedure Send (\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType ;\n    constant  Data            : in    std_logic_vector ;\n    constant  Param           : in    std_logic_vector ;\n    constant  StatusMsgOn     : in    boolean := FALSE \n  ) is \n    variable LocalParam : std_logic_vector(TransactionRec.ParamToModel'length -1 downto 0) := (others => '-') ;\n  begin\n    LocalParam(Param'length-1 downto 0) := Param ; \n    LocalSend(TransactionRec, SEND, Data, LocalParam, StatusMsgOn) ;\n  end procedure Send ; \n\n  ------------------------------------------------------------\n  procedure Send (\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType ;\n    constant  Data            : in    std_logic_vector ;\n    constant  StatusMsgOn     : in    boolean := FALSE \n  ) is \n    constant LocalParam : std_logic_vector(TransactionRec.ParamToModel'range) := (others => '-') ;\n  begin\n    LocalSend(TransactionRec, SEND, Data, LocalParam, StatusMsgOn);\n  end procedure Send ; \n\n  -- ========================================================\n  -- SendAsync\n  -- Asynchronous / Non-Blocking Send Transaction\n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for error injection. \n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure SendAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType ;\n    constant  Data            : in    std_logic_vector ;\n    constant  Param           : in    std_logic_vector ;\n    constant  StatusMsgOn     : in    boolean := FALSE \n  ) is \n    variable LocalParam : std_logic_vector(TransactionRec.ParamToModel'length -1 downto 0) := (others => '-') ;\n  begin\n    LocalParam(Param'length-1 downto 0) := Param ; \n    LocalSend(TransactionRec, SEND_ASYNC, Data, LocalParam, StatusMsgOn) ;\n  end procedure SendAsync ; \n\n  ------------------------------------------------------------\n  procedure SendAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType ;\n    constant  Data            : in    std_logic_vector ;\n    constant  StatusMsgOn     : in    boolean := FALSE \n  ) is \n    constant LocalParam : std_logic_vector(TransactionRec.ParamToModel'range) := (others => '-') ;\n  begin\n    LocalSend(TransactionRec, SEND_ASYNC, Data, LocalParam, StatusMsgOn);\n  end procedure SendAsync ; \n\n\n  -- ========================================================\n  -- SendBurst\n  -- Blocking Send Burst Transaction. \n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for error injection.\n  -- ========================================================\n  ------------------------------------------------------------\n  procedure LocalSendBurst (\n  -- Package Local - simplifies the other calls to Send\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType ;\n    constant  Operation       : in    StreamOperationType ;\n    constant  NumFifoWords    : In    integer ;\n    constant  Param           : in    std_logic_vector ;\n    constant  StatusMsgOn     : in    boolean := FALSE \n  ) is \n  begin\n    TransactionRec.Operation     <= Operation ;\n    TransactionRec.IntToModel    <= NumFifoWords ; \n    TransactionRec.ParamToModel  <= SafeResize(Param, TransactionRec.ParamToModel'length) ; \n    TransactionRec.BoolToModel   <= StatusMsgOn ; \n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ; \n  end procedure LocalSendBurst ; \n\n  ------------------------------------------------------------\n  procedure SendBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType ;\n    constant  NumFifoWords    : In    integer ;\n    constant  Param           : in    std_logic_vector ;\n    constant  StatusMsgOn     : in    boolean := FALSE \n  ) is \n    variable LocalParam : std_logic_vector(TransactionRec.ParamToModel'length -1 downto 0) := (others => '-') ;\n  begin\n    LocalParam(Param'length-1 downto 0) := Param ; \n    LocalSendBurst(TransactionRec, SEND_BURST, NumFifoWords, LocalParam, StatusMsgOn) ;\n  end procedure SendBurst ; \n\n  ------------------------------------------------------------\n  procedure SendBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType ;\n    constant  NumFifoWords    : In    integer ;\n    constant  StatusMsgOn     : in    boolean := FALSE \n  ) is \n    constant LocalParam : std_logic_vector(TransactionRec.ParamToModel'range) := (others => '-') ;\n  begin\n    LocalSendBurst(TransactionRec, SEND_BURST, NumFifoWords, LocalParam, StatusMsgOn) ;\n  end procedure SendBurst ; \n\n  -- ========================================================\n  -- SendBurstAsync\n  -- Asynchronous / Non-Blocking Send Transaction\n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for error injection. \n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure SendBurstAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType ;\n    constant  NumFifoWords    : In    integer ;\n    constant  Param           : in    std_logic_vector ;\n    constant  StatusMsgOn     : in    boolean := FALSE \n  ) is \n    variable LocalParam : std_logic_vector(TransactionRec.ParamToModel'length -1 downto 0) := (others => '-') ;\n  begin\n    LocalParam(Param'length-1 downto 0) := Param ; \n    LocalSendBurst(TransactionRec, SEND_BURST_ASYNC, NumFifoWords, LocalParam, StatusMsgOn) ;\n  end procedure SendBurstAsync ; \n\n  ------------------------------------------------------------\n  procedure SendBurstAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType ;\n    constant  NumFifoWords    : In    integer ;\n    constant  StatusMsgOn     : in    boolean := FALSE \n  ) is \n    constant LocalParam : std_logic_vector(TransactionRec.ParamToModel'range) := (others => '-') ;\n  begin\n    LocalSendBurst(TransactionRec, SEND_BURST_ASYNC, NumFifoWords, LocalParam, StatusMsgOn) ;\n  end procedure SendBurstAsync ; \n  \n\n  -- ========================================================\n  --  Receiver Transactions\n  -- ========================================================\n\n  -- ========================================================\n  -- Get\n  -- Blocking Get Transaction. \n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for received error status.\n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure Get (\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType ;\n    variable  Data            : out   std_logic_vector ;\n    constant  StatusMsgOn     : in    boolean := FALSE \n  ) is \n  begin\n    TransactionRec.Operation   <= GET ;\n    TransactionRec.IntToModel  <= Data'length ;\n    TransactionRec.BoolToModel <= StatusMsgOn ;     \n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ; \n    Data  := SafeResize(TransactionRec.DataFromModel, Data'length) ; \n  end procedure Get ; \n  \n  ------------------------------------------------------------\n  procedure Get (\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType ;\n    variable  Data            : out   std_logic_vector ;\n    variable  Param           : out   std_logic_vector ;\n    constant  StatusMsgOn     : in    boolean := FALSE \n  ) is \n  begin\n    Get(TransactionRec, Data, StatusMsgOn) ;\n    Param := SafeResize(TransactionRec.ParamFromModel, Param'length) ; \n  end procedure Get ;  \n\n  -- ========================================================\n  -- TryGet\n  -- Try Get Transaction\n  -- If Data is available, get it and return available TRUE,\n  -- otherwise Return Available FALSE.\n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for received error status.\n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure TryGet (\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType ;\n    variable  Data            : out   std_logic_vector ;\n    variable  Available       : out   boolean ;\n    constant  StatusMsgOn     : in    boolean := FALSE \n  ) is \n  begin\n    TransactionRec.Operation   <= TRY_GET ;\n    TransactionRec.IntToModel  <= Data'length ;\n    TransactionRec.BoolToModel <= StatusMsgOn ;     \n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ; \n    Data      := SafeResize(TransactionRec.DataFromModel, Data'length) ; \n    Available := TransactionRec.BoolFromModel ;\n  end procedure TryGet ; \n  \n  ------------------------------------------------------------\n  procedure TryGet (\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType ;\n    variable  Data            : out   std_logic_vector ;\n    variable  Param           : out   std_logic_vector ;\n    variable  Available       : out   boolean ;\n    constant  StatusMsgOn     : in    boolean := FALSE \n  ) is \n  begin\n    TryGet(TransactionRec, Data, Available, StatusMsgOn) ;\n    Param := SafeResize(TransactionRec.ParamFromModel, Param'length) ; \n  end procedure TryGet ;  \n\n\n  -- ========================================================\n  -- GetBurst\n  -- Blocking Get Burst Transaction. \n  -- Param, when present, is an extra parameter from the verification component\n  -- The UART verification component uses Param for received error status.\n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure GetBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType ;\n    variable  NumFifoWords    : inout integer ;\n    constant  StatusMsgOn     : in    boolean := FALSE \n  ) is \n  begin\n    TransactionRec.Operation   <= GET_BURST ;\n    TransactionRec.IntToModel  <= NumFifoWords ;  -- For models without burst framing (like UART)\n    TransactionRec.BoolToModel <= StatusMsgOn ;     \n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ; \n--    Last word of data, it maybe there, we don't return it, it is also in the BurstFifo\n--        Data  := SafeResize(TransactionRec.DataFromModel, Data'length) ; \n    NumFifoWords := TransactionRec.IntFromModel ;\n  end procedure GetBurst ; \n  \n  ------------------------------------------------------------\n  procedure GetBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType ;\n    variable  NumFifoWords    : inout integer ;\n    variable  Param           : out   std_logic_vector ;\n    constant  StatusMsgOn     : in    boolean := FALSE \n  ) is \n  begin\n    GetBurst(TransactionRec, NumFifoWords, StatusMsgOn) ;\n    Param := SafeResize(TransactionRec.ParamFromModel, Param'length) ; \n  end procedure GetBurst ;  \n\n  -- ========================================================\n  -- TryGetBurst\n  -- Try Get Burst Transaction\n  -- If Data is available, get it and return available TRUE,\n  -- otherwise Return Available FALSE.\n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for received error status.\n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure TryGetBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType ;\n    variable  NumFifoWords    : inout integer ;\n    variable  Available       : out   boolean ;\n    constant  StatusMsgOn     : in    boolean := FALSE \n  ) is \n  begin\n    TransactionRec.Operation   <= TRY_GET_BURST ;\n    TransactionRec.IntToModel  <= NumFifoWords ;  -- For models without burst framing (like UART)\n    TransactionRec.BoolToModel <= StatusMsgOn ;     \n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ; \n--    Last word of data, it maybe there, we don't return it, it is also in the BurstFifo\n--        Data  := SafeResize(TransactionRec.DataFromModel, Data'length) ; \n    NumFifoWords  := TransactionRec.IntFromModel ;\n    Available := TransactionRec.BoolFromModel ;\n  end procedure TryGetBurst ; \n  \n  ------------------------------------------------------------\n  procedure TryGetBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType ;\n    variable  NumFifoWords    : inout integer ;\n    variable  Param           : out   std_logic_vector ;\n    variable  Available       : out   boolean ;\n    constant  StatusMsgOn     : in    boolean := FALSE \n  ) is \n  begin\n    TryGetBurst(TransactionRec, NumFifoWords, Available, StatusMsgOn) ;\n    Param := SafeResize(TransactionRec.ParamFromModel, Param'length) ; \n  end procedure TryGetBurst ;  \n\n\n  -- ========================================================\n  -- Check\n  -- Blocking Get Transaction. \n  -- Data is the expected value to be received.\n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for received error status.\n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure Check (\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType ;\n    constant  Data            : in    std_logic_vector ;\n    constant  Param           : in    std_logic_vector ;\n    constant  StatusMsgOn     : in    boolean := FALSE \n  ) is \n    variable LocalParam : std_logic_vector(TransactionRec.ParamToModel'length -1 downto 0) := (others => '-') ;\n  begin\n    LocalParam(Param'length-1 downto 0) := Param ; \n    TransactionRec.Operation     <= CHECK ;\n    TransactionRec.DataToModel   <= SafeResize(Data, TransactionRec.DataToModel'length) ; \n    TransactionRec.ParamToModel  <= SafeResize(LocalParam, TransactionRec.ParamToModel'length) ; \n    TransactionRec.IntToModel    <= Data'length ;\n    TransactionRec.BoolToModel   <= StatusMsgOn ;     \n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ; \n  end procedure Check ; \n\n  ------------------------------------------------------------\n  procedure Check (\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType ;\n    constant  Data            : in    std_logic_vector ;\n    constant  StatusMsgOn     : in    boolean := FALSE \n  ) is \n    constant Param : std_logic_vector(TransactionRec.ParamToModel'range) := (others => '-') ;\n  begin\n    Check(TransactionRec, Data, Param, StatusMsgOn) ;\n  end procedure Check ; \n\n\n  -- ========================================================\n  -- TryCheck\n  -- Try Check Transaction\n  -- If Data is available, check it and return available TRUE,\n  -- otherwise Return Available FALSE.\n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for received error status.\n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure TryCheck (\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType ;\n    constant  Data            : in    std_logic_vector ;\n    constant  Param           : in    std_logic_vector ;\n    variable  Available       : out   boolean ;\n    constant  StatusMsgOn     : in    boolean := FALSE \n  ) is \n    variable LocalParam : std_logic_vector(TransactionRec.ParamToModel'length -1 downto 0) := (others => '-') ;\n  begin\n    LocalParam(Param'length-1 downto 0) := Param ; \n    TransactionRec.Operation     <= TRY_CHECK ;\n    TransactionRec.DataToModel   <= SafeResize(Data, TransactionRec.DataToModel'length) ; \n    TransactionRec.ParamToModel  <= SafeResize(LocalParam, TransactionRec.ParamToModel'length) ; \n    TransactionRec.IntToModel    <= Data'length ;\n    TransactionRec.BoolToModel   <= StatusMsgOn ;     \n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ; \n    Available := TransactionRec.BoolFromModel ;\n  end procedure TryCheck ; \n\n  ------------------------------------------------------------\n  procedure TryCheck (\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType ;\n    constant  Data            : in    std_logic_vector ;\n    variable  Available       : out   boolean ;\n    constant  StatusMsgOn     : in    boolean := FALSE \n  ) is \n    constant Param : std_logic_vector(TransactionRec.ParamToModel'range) := (others => '-') ;\n  begin\n    TryCheck(TransactionRec, Data, Param, Available, StatusMsgOn) ;\n  end procedure TryCheck ; \n\n\n  -- ========================================================\n  -- CheckBurst\n  -- Blocking Check Burst Transaction. \n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for checking error injection.\n  -- ========================================================\n  ------------------------------------------------------------\n  procedure LocalCheckBurst (\n  -- Package Local - simplifies the other calls to Check\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType ;\n    constant  Operation       : in    StreamOperationType ;\n    constant  NumFifoWords    : In    integer ;\n    constant  Param           : in    std_logic_vector ;\n    constant  StatusMsgOn     : in    boolean := FALSE \n  ) is \n  begin\n    TransactionRec.Operation     <= Operation ;\n    TransactionRec.IntToModel    <= NumFifoWords ; \n    TransactionRec.ParamToModel  <= SafeResize(Param, TransactionRec.ParamToModel'length) ; \n    TransactionRec.BoolToModel   <= StatusMsgOn ; \n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ; \n  end procedure LocalCheckBurst ; \n\n  ------------------------------------------------------------\n  procedure CheckBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType ;\n    constant  NumFifoWords    : In    integer ;\n    constant  Param           : in    std_logic_vector ;\n    constant  StatusMsgOn     : in    boolean := FALSE \n  ) is \n    variable LocalParam : std_logic_vector(TransactionRec.ParamToModel'length -1 downto 0) := (others => '-') ;\n  begin\n    LocalParam(Param'length-1 downto 0) := Param ; \n    LocalCheckBurst(TransactionRec, CHECK_BURST, NumFifoWords, LocalParam, StatusMsgOn) ;\n  end procedure CheckBurst ; \n\n  ------------------------------------------------------------\n  procedure CheckBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType ;\n    constant  NumFifoWords    : In    integer ;\n    constant  StatusMsgOn     : in    boolean := FALSE \n  ) is \n    constant LocalParam : std_logic_vector(TransactionRec.ParamToModel'range) := (others => '-') ;\n  begin\n    LocalCheckBurst(TransactionRec, CHECK_BURST, NumFifoWords, LocalParam, StatusMsgOn) ;\n  end procedure CheckBurst ; \n\n  -- ========================================================\n  -- TryCheckBurst\n  -- Try / Non-Blocking Check Burst Transaction\n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for error injection. \n  -- ========================================================\n  ------------------------------------------------------------\n  procedure TryCheckBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType ;\n    constant  NumFifoWords    : In    integer ;\n    constant  Param           : in    std_logic_vector ;\n    variable  Available       : out   boolean ;\n    constant  StatusMsgOn     : in    boolean := FALSE \n  ) is \n    variable LocalParam : std_logic_vector(TransactionRec.ParamToModel'length -1 downto 0) := (others => '-') ;\n  begin\n    LocalParam(Param'length-1 downto 0) := Param ; \n    LocalCheckBurst(TransactionRec, TRY_CHECK_BURST, NumFifoWords, LocalParam, StatusMsgOn) ;\n    Available := TransactionRec.BoolFromModel ;\n  end procedure TryCheckBurst ; \n\n  ------------------------------------------------------------\n  procedure TryCheckBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType ;\n    constant  NumFifoWords    : In    integer ;\n    variable  Available       : out   boolean ;\n    constant  StatusMsgOn     : in    boolean := FALSE \n  ) is \n    constant LocalParam : std_logic_vector(TransactionRec.ParamToModel'range) := (others => '-') ;\n  begin\n    LocalCheckBurst(TransactionRec, TRY_CHECK_BURST, NumFifoWords, LocalParam, StatusMsgOn) ;\n    Available := TransactionRec.BoolFromModel ;\n  end procedure TryCheckBurst ; \n\n\n  -- ========================================================\n  --  Pseudo Transactions\n  --  Interact with the record only.\n  -- ========================================================\n  ------------------------------------------------------------\n  procedure ReleaseTransactionRecord (\n  --  Must run on same delta cycle as AcquireTransactionRecord\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType \n  ) is\n  begin\n    -- Set everything driven by TestCtrl to type'left (except Rdy)\n    TransactionRec.Rdy           <= RdyType'left ;   \n    TransactionRec.Operation     <= NOT_DRIVEN ;\n    TransactionRec.DataToModel   <= (TransactionRec.DataToModel'range => 'U') ;\n    TransactionRec.ParamToModel  <= (TransactionRec.ParamToModel'range => 'U') ;\n    TransactionRec.IntToModel    <= integer'left ; \n    TransactionRec.BoolToModel   <= boolean'left ; \n    TransactionRec.TimeToModel   <= time'left ; \n    TransactionRec.Options       <= integer'left ;    \n  end procedure ReleaseTransactionRecord ; \n  \n  ------------------------------------------------------------\n  procedure AcquireTransactionRecord (\n  --  Must run on same delta cycle as ReleaseTransactionRecord\n  ------------------------------------------------------------\n    signal    TransactionRec  : inout StreamRecType \n  ) is\n  begin\n    -- Start Driving Rdy on next delta cycle with the current value.  \n    TransactionRec.Rdy           <= TransactionRec.Rdy ; \n  end procedure AcquireTransactionRecord ; \n\n\n  -- ========================================================\n  --  Verification Component Support Functions\n  --  These help decode the operation value (StreamOperationType)  \n  --  to determine properties about the operation\n  -- ========================================================\n  ------------------------------------------------------------\n  function IsBlocking (\n  -----------------------------------------------------------\n    constant Operation     : in StreamOperationType\n  ) return boolean is\n  begin\n    return (Operation = SEND) or (Operation = GET) or (Operation = CHECK) or \n           (Operation = SEND_BURST) or (Operation = GET_BURST) or (Operation = CHECK_BURST)  ;\n  end function IsBlocking ;\n\n  ------------------------------------------------------------\n  function IsTry (\n  -----------------------------------------------------------\n    constant Operation     : in StreamOperationType\n  ) return boolean is\n  begin\n    return (Operation = TRY_GET) or (Operation = TRY_CHECK) or (Operation = TRY_GET_BURST) or (Operation = TRY_CHECK_BURST) ;\n  end function IsTry ;\n\n  ------------------------------------------------------------\n  function IsCheck (\n  -----------------------------------------------------------\n    constant Operation     : in StreamOperationType\n  ) return boolean is\n  begin\n    return (Operation = CHECK) or (Operation = TRY_CHECK) or (Operation = CHECK_BURST) or (Operation = TRY_CHECK_BURST) ;\n  end function IsCheck ;\n\nend StreamTransactionPkg ;","lang":"vhdl"};
processSrcData(g_data);