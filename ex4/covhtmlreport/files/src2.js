var g_data = {"name":"/home/ferringer/private/lva/labs/vhdl/osvvm/Common/src/FifoFillPkg_slv.vhd","src":"--\n--  File Name:         FifoFillPkg_slv.vhd\n--  Design Unit Name:  FifoFillPkg_slv\n--  Revision:          STANDARD VERSION\n--\n--  Maintainer:        Jim Lewis      email:  jim@synthworks.com\n--  Contributor(s):\n--     Jim Lewis          email:  jim@synthworks.com\n--\n--\n--  Description:\n--    Fill and check data in burst fifos \n--    Defines type ScoreBoardPType\n--    Defines methods for putting values the scoreboard\n--\n--  Developed for:\n--        SynthWorks Design Inc.\n--        VHDL Training Classes\n--        11898 SW 128th Ave.  Tigard, Or  97223\n--        http://www.SynthWorks.com\n--\n--  Revision History:\n--    Date      Version     Description\n--    06/2021   2021.06     Updated to work with new FIFO/Scoreboard data structures\n--    10/2020   2020.10     Updating comments to serve as documentation\n--    09/2020   2020.09     Updating comments to serve as documentation\n--    05/2020   2020.05     Initial revision\n--\n--  This file is part of OSVVM.\n--  \n--  Copyright (c) 2020 by SynthWorks Design Inc.  \n--  \n--  Licensed under the Apache License, Version 2.0 (the \"License\");\n--  you may not use this file except in compliance with the License.\n--  You may obtain a copy of the License at\n--  \n--      https://www.apache.org/licenses/LICENSE-2.0\n--  \n--  Unless required by applicable law or agreed to in writing, software\n--  distributed under the License is distributed on an \"AS IS\" BASIS,\n--  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--  See the License for the specific language governing permissions and\n--  limitations under the License.\n--  \n\n\nuse std.textio.all ;\n\nlibrary ieee ;\n  use ieee.std_logic_1164.all ;\n  use ieee.numeric_std.all ;\n  use ieee.numeric_std_unsigned.all ;\n  \nlibrary osvvm ; \n  context osvvm.OsvvmContext ;   \n  use osvvm.ScoreboardPkg_slv.all ;\n\n--!! Can this be made a generic package.   \n\npackage FifoFillPkg_slv is\n  ------------------------------------------------------------\n  procedure PushBurst (\n  -- Push each value in the VectorOfWords parameter into the FIFO.   \n  -- Only FifoWidth bits of each value will be pushed.    \n  ------------------------------------------------------------\n    constant Fifo           : in    ScoreboardIdType ;\n    constant VectorOfWords  : in    integer_vector ;\n    constant FifoWidth      : in    integer := 8\n  ) ;\n\n  ------------------------------------------------------------\n  procedure PushBurstIncrement (\n  -- Push Count number of values into FIFO.  The first value \n  -- pushed will be FirstWord and following values are one greater \n  -- than the previous one.  \n  -- Only FifoWidth bits of each value will be pushed.    \n  ------------------------------------------------------------\n    constant Fifo      : in    ScoreboardIdType ;\n    constant FirstWord : in    integer ;\n    constant Count     : in    integer ;\n    constant FifoWidth : in    integer := 8\n  ) ;\n  \n  ------------------------------------------------------------\n  procedure PushBurstRandom (\n  -- Push Count number of values into FIFO.  The first value \n  -- pushed will be FirstWord and following values are randomly generated \n  -- using the first value as the randomization seed.\n  -- Only FifoWidth bits of each value will be pushed.    \n  ------------------------------------------------------------\n    constant Fifo      : in    ScoreboardIdType ;\n    constant FirstWord : in    integer ;\n    constant Count     : in    integer ;\n    constant FifoWidth : in    integer := 8\n  ) ;\n  \n  ------------------------------------------------------------\n  procedure PopBurst (\n  -- Pop values from the FIFO into the VectorOfWords parameter.\n  -- Each value popped will be FifoWidth bits wide.   \n  ------------------------------------------------------------\n    constant Fifo           : in    ScoreboardIdType ;\n    variable VectorOfWords  : out   integer_vector ;\n    constant FifoWidth      : in    integer := 8\n  ) ;\n\n  ------------------------------------------------------------\n  procedure CheckBurst (\n  -- Pop values from the FIFO and check them against each value \n  -- in the VectorOfWords parameter.   \n  -- Each value popped will be FifoWidth bits wide.   \n  ------------------------------------------------------------\n    constant Fifo           : in    ScoreboardIdType ;\n    constant VectorOfWords  : in    integer_vector ;\n    constant FifoWidth      : in    integer := 8\n  ) ;\n\n  ------------------------------------------------------------\n  procedure CheckBurstIncrement (\n  -- Pop values from the FIFO and check them against values determined \n  -- by an incrementing pattern.  The first check value will be FirstWord  \n  -- and the following check values are one greater than the previous one.  \n  -- Each value popped will be FifoWidth bits wide.   \n  ------------------------------------------------------------\n    constant Fifo      : in    ScoreboardIdType ;\n    constant FirstWord : in    integer ;\n    constant Count     : in    integer ;\n    constant FifoWidth : in    integer := 8\n  ) ;\n  \n  ------------------------------------------------------------\n  procedure CheckBurstRandom (\n  -- Pop values from the FIFO and check them against values determined \n  -- by a random pattern.  The first check value will be FirstWord and the\n  -- following check values are randomly generated using the first  \n  -- value as the randomization seed.  \n  -- Each value popped will be FifoWidth bits wide.   \n  ------------------------------------------------------------\n    constant Fifo      : in    ScoreboardIdType ;\n    constant FirstWord : in    integer ;\n    constant Count     : in    integer ;\n    constant FifoWidth : in    integer := 8\n  ) ;\n\n\n  -- ========================================================\n  --  Verification Component Support\n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure PopWord (\n  -- Pop bytes from BurstFifo and form a word \n  -- Current implementation for now assumes it is assembling bytes.   \n  --\n  ------------------------------------------------------------\n    constant Fifo              : in    ScoreboardIdType ;\n    variable Valid             : out   boolean ;\n    variable Data              : out   std_logic_vector ; \n    variable BytesToSend       : inout integer ;\n    constant ByteAddress       : in    natural := 0 \n  ) ; \n\n  ------------------------------------------------------------\n  procedure PushWord (\n  -- Push a word into the byte oriented BurstFifo\n  -- Current implementation for now assumes it is assembling bytes.   \n  --\n  ------------------------------------------------------------\n    constant Fifo              : in    ScoreboardIdType ;\n    variable Data              : in    std_logic_vector ; \n    constant DropUndriven      : in    boolean := FALSE ;\n    constant ByteAddress       : in    natural := 0 \n  ) ; \n  \n  ------------------------------------------------------------\n  procedure CheckWord (\n  -- Check a word using the byte oriented BurstFifo\n  -- Current implementation for now assumes it is assembling bytes.   \n  --\n  ------------------------------------------------------------\n    constant Fifo              : in    ScoreboardIdType ;\n    variable Data              : in    std_logic_vector ; \n    constant DropUndriven      : in    boolean := FALSE ;\n    constant ByteAddress       : in    natural := 0 \n  ) ;\n\n  ------------------------------------------------------------\n  function CountBytes(\n  -- Count number of bytes in a word\n  --\n  ------------------------------------------------------------\n    constant Data              : std_logic_vector ;\n    constant DropUndriven      : in    boolean := FALSE ;\n    constant ByteAddress       : in    natural := 0 \n  ) return integer ;\n  \nend package FifoFillPkg_slv ;\n\n-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\npackage body FifoFillPkg_slv is\n  constant NUMBER_POSITIVE_INTEGER_BITS : integer := 31 ; \n\n  ------------------------------------------------------------\n  procedure PushBurst (\n  ------------------------------------------------------------\n    constant Fifo           : in    ScoreboardIdType ;\n    constant VectorOfWords  : in    integer_vector ;\n    constant FifoWidth      : in    integer := 8\n  ) is\n  begin\n    for i in VectorOfWords'range loop \n      if VectorOfWords(i) < 0 then \n        Push(Fifo, (FifoWidth downto 1 => 'U')) ;\n      else \n        Push(Fifo, to_slv(VectorOfWords(i), FifoWidth)) ;\n      end if ;\n    end loop ;\n  end procedure PushBurst ;\n\n  ------------------------------------------------------------\n  procedure PushBurstIncrement (\n  ------------------------------------------------------------\n    constant Fifo      : in    ScoreboardIdType ;\n    constant FirstWord : in    integer ;\n    constant Count     : in    integer ;\n    constant FifoWidth : in    integer := 8\n  ) is\n  begin\n    for i in FirstWord to Count+FirstWord-1 loop \n      if FifoWidth < NUMBER_POSITIVE_INTEGER_BITS then \n        Push(Fifo, to_slv(i mod (2**FifoWidth), FifoWidth)) ;\n      else \n        Push(Fifo, to_slv(i, FifoWidth)) ;\n      end if ; \n    end loop ;\n  end procedure PushBurstIncrement ;\n  \n  ------------------------------------------------------------\n  procedure PushBurstRandom (\n  ------------------------------------------------------------\n    constant Fifo      : in    ScoreboardIdType ;\n    constant FirstWord : in    integer ;\n    constant Count     : in    integer ;\n    constant FifoWidth : in    integer := 8\n  ) is\n    variable RV : RandomPType ; \n    variable JunkValue : integer ;\n    variable Data : std_logic_vector(FifoWidth-1 downto 0) ;\n  begin\n    -- Initialize seed and toss first random value  \n    RV.InitSeed(FirstWord) ;\n    JunkValue := RV.RandInt(1, 10) ;  -- toss\n    \n    if FifoWidth < NUMBER_POSITIVE_INTEGER_BITS then \n      Push(Fifo, to_slv(FirstWord mod (2**FifoWidth), FifoWidth)) ;\n    else \n      Push(Fifo, to_slv(FirstWord, FifoWidth)) ;\n    end if ; \n    \n    for i in 2 to Count loop \n      Data := RV.RandSlv(FifoWidth) ;\n      Push(Fifo, Data) ;\n    end loop ;\n  end procedure PushBurstRandom ;\n  \n  ------------------------------------------------------------\n  procedure PopBurst (\n  ------------------------------------------------------------\n    constant Fifo           : in    ScoreboardIdType ;\n    variable VectorOfWords  : out   integer_vector ;\n    constant FifoWidth      : in    integer := 8\n  ) is\n  begin\n    for i in VectorOfWords'range loop \n      if VectorOfWords(i) < 0 then \n        Push(Fifo, (FifoWidth downto 1 => 'U')) ;\n      else \n        Push(Fifo, to_slv(VectorOfWords(i), FifoWidth)) ;\n      end if ;\n    end loop ;\n  end procedure PopBurst ;\n  \n  ------------------------------------------------------------\n  procedure CheckBurst (\n  ------------------------------------------------------------\n    constant Fifo           : in    ScoreboardIdType ;\n    constant VectorOfWords  : in    integer_vector ;\n    constant FifoWidth      : in    integer := 8\n  ) is\n    variable AlertLogID : AlertLogIDType ; \n    variable RxVal : std_logic_vector(FifoWidth-1 downto 0) ;\n  begin\n    AlertLogID := GetAlertLogID(Fifo) ; \n    for i in VectorOfWords'range loop \n      RxVal := Pop(Fifo) ;\n      if VectorOfWords(i) < 0 then \n        AffirmIfEqual(AlertLogID, RxVal, (FifoWidth downto 1 => 'U')) ;\n      else \n        AffirmIfEqual(AlertLogID, RxVal, to_slv(VectorOfWords(i), FifoWidth)) ;\n      end if ;\n    end loop ;\n  end procedure CheckBurst ;\n\n  ------------------------------------------------------------\n  procedure CheckBurstIncrement (\n  ------------------------------------------------------------\n    constant Fifo      : in    ScoreboardIdType ;\n    constant FirstWord : in    integer ;\n    constant Count     : in    integer ;\n    constant FifoWidth : in    integer := 8\n  ) is\n    variable AlertLogID : AlertLogIDType ; \n    variable RxVal : std_logic_vector(FifoWidth-1 downto 0) ;\n  begin\n    AlertLogID := GetAlertLogID(Fifo) ; \n    for i in FirstWord to Count+FirstWord-1 loop \n      RxVal := Pop(Fifo) ;\n      if FifoWidth < NUMBER_POSITIVE_INTEGER_BITS then \n        AffirmIfEqual(AlertLogID, RxVal, to_slv(i mod (2**FifoWidth), FifoWidth)) ;\n      else \n        AffirmIfEqual(AlertLogID, RxVal, to_slv(i, FifoWidth)) ;\n      end if ; \n    end loop ;\n  end procedure CheckBurstIncrement ;\n  \n  ------------------------------------------------------------\n  procedure CheckBurstRandom (\n  ------------------------------------------------------------\n    constant Fifo      : in    ScoreboardIdType ;\n    constant FirstWord : in    integer ;\n    constant Count     : in    integer ;\n    constant FifoWidth : in    integer := 8\n  ) is\n    variable RV : RandomPType ; \n    variable JunkValue : integer ;\n    variable AlertLogID : AlertLogIDType ; \n    variable RxVal, ExpVal : std_logic_vector(FifoWidth-1 downto 0) ;\n  begin\n    AlertLogID := GetAlertLogID(Fifo) ; \n    -- Initialize seed and toss first random value \n    RV.InitSeed(FirstWord) ;\n    JunkValue := RV.RandInt(1, 10) ;  -- Toss\n    \n    RxVal := Pop(Fifo) ;\n    -- Check First Value      Received    Expected, First Value\n    if FifoWidth < NUMBER_POSITIVE_INTEGER_BITS then \n      AffirmIfEqual(AlertLogID, RxVal, to_slv(FirstWord mod (2**FifoWidth), FifoWidth)) ;\n    else \n      AffirmIfEqual(AlertLogID, RxVal, to_slv(FirstWord, FifoWidth)) ;\n    end if ; \n    \n    for i in 2 to Count loop \n      RxVal := Pop(Fifo) ;\n      ExpVal := RV.RandSlv(FifoWidth) ;\n      -- Check Remaining Values   Received    Expected\n      AffirmIfEqual(AlertLogID,   RxVal,      ExpVal ) ;\n    end loop ;\n  end procedure CheckBurstRandom ;\n  \n  \n  -- ========================================================\n  --  Verification Component Support\n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure PopWord (\n  -- Pop bytes from BurstFifo and form a word \n  -- Current implementation for now assumes it is assembling bytes.   \n  --\n  ------------------------------------------------------------\n    constant Fifo              : in    ScoreboardIdType ;\n    variable Valid             : out   boolean ;\n    variable Data              : out   std_logic_vector ; \n    variable BytesToSend       : inout integer ;\n    constant ByteAddress       : in    natural := 0 \n  ) is\n    variable Index    : integer := ByteAddress * 8 ; \n    constant DataLeft : integer := Data'length-1; \n    alias aData       : std_logic_vector(DataLeft downto 0) is Data;\n  begin\n    aData := (aData'range => 'U') ;  -- Default Undriven\n    Valid := TRUE ; \n    GetWord : while Index <= DataLeft loop  \n      if not Empty(Fifo) then \n        aData(Index+7 downto Index) := Pop(Fifo) ; \n        BytesToSend := BytesToSend - 1 ; \n        exit when BytesToSend = 0 ; \n      else\n        Valid := FALSE ; \n        exit ; \n      end if ; \n      Index := Index + 8 ; \n    end loop GetWord ;\n  end PopWord ; \n\n  ------------------------------------------------------------\n  procedure PushWord (\n  -- Push a word into the byte oriented BurstFifo\n  -- Current implementation for now assumes it is assembling bytes.   \n  --\n  ------------------------------------------------------------\n    constant Fifo              : in    ScoreboardIdType ;\n    variable Data              : in    std_logic_vector ; \n    constant DropUndriven      : in    boolean := FALSE ;\n    constant ByteAddress       : in    natural := 0 \n  ) is\n    variable Index    : integer := ByteAddress * 8 ; \n    constant DataLeft : integer := Data'length-1; \n    alias    aData    : std_logic_vector(DataLeft downto 0) is Data;\n  begin\n    PushBytes : while Index <= DataLeft loop  \n      if not ((DropUndriven and aData(Index) = 'U') or aData(Index) = '-') then \n        Push(Fifo, aData(Index+7 downto Index)) ; \n      end if ;\n      Index := Index + 8 ; \n    end loop PushBytes ; \n  end PushWord ; \n\n  ------------------------------------------------------------\n  procedure CheckWord (\n  -- Push a word into the byte oriented BurstFifo\n  -- Current implementation for now assumes it is assembling bytes.   \n  --\n  ------------------------------------------------------------\n    constant Fifo              : in    ScoreboardIdType ;\n    variable Data              : in    std_logic_vector ; \n    constant DropUndriven      : in    boolean := FALSE ;\n    constant ByteAddress       : in    natural := 0 \n  ) is\n    variable Index    : integer := ByteAddress * 8 ; \n    constant DataLeft : integer := Data'length-1; \n    alias aData       : std_logic_vector(DataLeft downto 0) is Data;\n  begin\n    PushBytes : while Index <= DataLeft loop  \n      if not ((DropUndriven and aData(Index) = 'U') or aData(Index) = '-') then \n        Check(Fifo, aData(Index+7 downto Index)) ; \n      end if ;\n      Index := Index + 8 ; \n    end loop PushBytes ; \n  end CheckWord ; \n\n  ------------------------------------------------------------\n  function CountBytes(\n  -- Count number of bytes in a word\n  --\n  ------------------------------------------------------------\n    constant Data              : std_logic_vector ;\n    constant DropUndriven      : in    boolean := FALSE ;\n    constant ByteAddress       : in    natural := 0 \n  ) return integer is\n    variable Index    : integer := ByteAddress * 8 ; \n    variable Count    : integer := 0 ; \n    constant DataLeft : integer := Data'length-1 ;\n    alias aData       : std_logic_vector(DataLeft downto 0) is Data ; \n  begin\n    while Index <= DataLeft loop\n      if not ((DropUndriven and aData(Index) = 'U') or aData(Index) = '-') then \n        Count := Count + 1 ; \n      end if ;\n      Index := Index + 8 ; \n    end loop ; \n    return Count ;\n  end function CountBytes ; \n    \nend FifoFillPkg_slv ;","lang":"vhdl"};
processSrcData(g_data);